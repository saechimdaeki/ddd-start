# Chap 11. CQRS

## 단일 모델의 단점
주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야한다. Order에서 주문 정보를 가져와야 하고, Product에서 상품 이름을

가져와야 하고, Member에서 회원 이름과 ID를 가져와야 한다.

<img width="385" alt="image" src="https://user-images.githubusercontent.com/40031858/170387168-daaf32db-f9f5-45e6-8310-93a026931362.png">


조회 화면 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야 한다. 

애그리거트 간 연관을 식별자가 아니라 직접 참조하는 방식으로 연결해도 고민거리가 생긴다. 이런 고민이 발생하는 이유는 시스템 상태를 변경할 때와

조회할 때 단일 도메인 모델을 사용하기 때문이다. 객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM기법은 Order#cancel()이나

Order#changeShippingInfo() 기능처럼 도메인 상태 변경 기능을 구현하는데는 적합하지만 주문 상세 조회 화면처럼 여러 애그리거트에서

데이터를 가져와 출력하는 기능을 구현하기에는 고려할 게 많아서 구현을 복잡하게 만드는 원인이 된다.

이런 구현 복잡도를 낮추는 간단한 방법이 있는데 그것은 바로 `상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다`

## CQRS

시스템이 제공하는 기능은 크게 두 가지로 나눌 수 있다. 하나는 상태를 변경하는 기능이다. 새로운 주문을 생성하거나, 배송지 정보를 변경하거나,

회원 암호를 변경하는 기능이 이에 해당한다. 개발자는 현재 저장하고 있는 데이터를 변경하는 방식으로 기능을 구현한다.

또 다른 하나는 사용자 입장에서 상태 정보를 조회한느 기능이다. 주문 상세 내역 보기, 게시글 목록 보기, 회원 정보 보기, 판매 통계 보기가 이에 해당한다.

조회 기능은 필요한 데이터를 읽어와 UI를 통해 보여주는 방식으로 구현한다.

도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다. 예를 들어 주문 취소 기능과 배송지 정보 변경 기능은 한 개의 Order애그리거트를 변경한다.

상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.

단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 있는데 바로 `CQRS`다.

`CQRS`는 Command Query Responsibility Segregation의 약자로 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴이다.


<img width="728" alt="image" src="https://user-images.githubusercontent.com/40031858/170388936-fd0636e2-5c79-4e4b-82fa-cca5e9d685c8.png">

`CQRS`는 복잡한 도메인에 적합핟. 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 난다. 이 두기능을 단일 모델로 처리하면 조회 기능의 로딩 

속도를 위해 모델 구현이 필요 이상으로 복잡해진다. 

`CQRS`를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다. 예를 들어 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현하고,

조회 모델은 DB 테이블에서 SQL로 데이터를 조회할 때 좋은 마이바티스를 사용해서 구현하면 된다.

<img width="491" alt="image" src="https://user-images.githubusercontent.com/40031858/170389441-8962dc8b-b74a-442d-a6b5-b65840fe96fa.png">

위 그림을 보면 조회 모델에는 응용 서비스가 존재하지 않는다. 단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하지 않기

때문에 컨트롤러에서 바로 DAO를 실행해도 무방하다. 물론 데이터를 표현 영역에 전달하는 과정에서 몇가지 로직이 필요하다면 응용서비스를 두고 로직을 구현하면된다.

<img width="772" alt="image" src="https://user-images.githubusercontent.com/40031858/170390449-298db653-569c-48dc-b191-80e427a50438.png">

명령 모델과 조회 모델이 같은 구현기술을 사용할 수도 있다. 동적 인스턴스로 사용할 클래스와 @Subselect를 적용한 클래스가 조회 모델에 해당한다.

<img width="893" alt="image" src="https://user-images.githubusercontent.com/40031858/170390871-98e65b1e-a678-411d-b2a7-dd905b27ab76.png">

그림과 같이 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다. 명령 모델은 트랜잭션을 지원하는 RDBMS를 사용하고,

조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을 사용할 수 있을 것이다.

두 데이터 저장소 간 데이터 동기화는 `이벤트`를 활용해서 처리한다. 명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영하면된다.

명령 모델과 조회 모델이 서로 다른 데이터 저장솔르 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다. 명령 모델에서 데이터가 바뀌자마자 변경 내역을 바로 

조회 모델에 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화할 수 있다.

서로 다른 저장소의 데이터를 특정 시간 안에만 동기화해도 된다면 비동기로 데이터를 전송하면 된다. 예를 들어 통계 처리 목적으로 조회 전용 저장소를 구축햇다고 하자. 통계 데이터는

수초, 수분 또는 1시간 단위로 최근 데이터를 반영해도 문제가 되지 않을 때가 많다. 이런 경우라면 비동기로 데이터를 보냄으로써 데이터 동기화로 인해

명령 모델의 성능이 나빠지지 않도록 할 수 있다.

### 웹과 CQRS
일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다. 포털이나 대형 온라인 쇼핑몰과 같이 조회 기능 요청 비율이

월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 다양한 기법을 사용한다. 기본적으로 쿼리를 최적화해서 쿼리 실행 속도 자체를 높이고,

메모리에 조회 데이터를 캐싱해서 응답 속도를 높이기도 한다. 조회 전용 저장소를 따로 사용하기도 한다. 이렇게 조회 성능을 높이기 위해

다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용하는 것과 같은 효과를 만든다. 메모리에 캐싱 하는 데이터는 DB에 보관된 데이터를 그대로 저장하기보다는

화면에 맞는 모양으로 변환한 데이터를 캐싱 할 때 성능에 더 유리하다. 즉, 조회 전용 모델을 캐시하는 것이다.

### CQRS장단점

CQRS패턴을 적용할 때 얻을 수 있는 장점은 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다는 점이다. 복잡한 도메인은 주로 상태 변경 로직이 복잡한데 명령 모델과

조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는 데 집중할 수 있다. 또한 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다.

또 다른 장점은 조회 성능을 향상시키는 데 유리하다는 점이다. 조회 단위로 캐시 기술을 적용 할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수도 있다.

캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수도 있다. 조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.

<img width="514" alt="image" src="https://user-images.githubusercontent.com/40031858/170391863-bb8065df-ffd5-4440-9fa4-e715fd245af8.png">

물론 단점도 있다. 첫 번째 단점은 구현해야 할 코드가 더 많다는 점이다. 단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과

조회 전용 모델을 만들 때 발생하는 구현 비용을 따져봐야 한다. 도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을

만드는 것이 향후 유지 보수에 유리하다. 반면에 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 따로 만들 때 얻을 이점이 있는지 따져봐야 한다.

두 번째 단점은 더 많은 구현 기술이 필요하다는 것이다. 명령 모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 하고 경우에 따라

다른 저장소를 사용하기도 한다. 또한 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있다.

이러한 장단점을 고려해서 CQRS패턴을 도입할지 여부를 결정해야 한다. 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만

높아지고 얻을 수 있는 이점은 없다. 반면에 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지 보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려하자.